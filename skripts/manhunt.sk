command /manhunt [<text>] [<player>]:
	permission: skript.events
	trigger:
		if arg-1 is not set:
			send "&cUsage: /manhunt <set|start|pause|resume|stop>"
			stop

		if arg-1 is "set":
			if arg-2 is not a player:
				send "&cProvide a valid player."
				stop
			set {runner} to arg-2
			clear {hunters::*}
			loop all players:
				if loop-player is not arg-2:
					add loop-player to {hunters::*}
			broadcast "&aRunner set to %{runner}%."
			stop

		if arg-1 is "start":
			if {runner} is not set:
				send "&cSet a runner first."
				stop

			set {active} to true
			set {paused} to false
			set {time} to 3600
			delete {netherPortal}
			delete {endPortal}

			loop all players:
				set gamemode of loop-player to spectator

			send title "&6Manhunt Starting" with subtitle "&e15 seconds..." to all players
			wait 5 seconds
			send title "&e10 seconds..." to all players
			wait 5 seconds

			set {_c} to 5
			loop 5 times:
				send title "&a%{_c}%" to all players
				play sound "block.end_portal_frame.fill" to all players
				remove 1 from {_c}
				wait 1 second

			send title "&6GO!" to all players
			play sound "block.end_portal.spawn" to all players

			set gamemode of {runner} to survival

			set {_tracker} to compass
			set name of {_tracker} to "&6&lTRACKER"

			loop {hunters::*}:
				set {_p} to loop-value
				if {_p} is online:
					set gamemode of {_p} to survival
					give {_tracker} to {_p}

			broadcast "&aManhunt has begun."
			stop

		if arg-1 is "pause":
			if {active} is not true:
				send "&cNo active manhunt."
				stop
			set {paused} to true
			broadcast "&eManhunt paused."
			stop

		if arg-1 is "resume":
			if {active} is not true:
				send "&cNo active manhunt."
				stop
			set {paused} to false
			broadcast "&aManhunt resumed."
			stop

		if arg-1 is "stop":
			if {active} is not true:
				send "&cNo active manhunt."
				stop
			delete {runner}
			delete {hunters::*}
			delete {active}
			delete {paused}
			delete {time}
			delete {netherPortal}
			delete {endPortal}
			broadcast "&cManhunt stopped."
			stop


every 1 second:
	if {active} is not true:
		stop
	if {paused} is true:
		stop

	remove 1 from {time}
	set {_min} to floor({time} / 60)
	set {_sec} to {time} - ({_min} * 60)

	loop all players:
		if {time} < 10:
			send action bar "&c0%{time}% seconds remaining." to loop-player
		else:
			send action bar "&e%{_min}%m %{_sec}%s remaining." to loop-player

	if {time} <= 0:
		broadcast "&aRunner survived. Runner wins."
		delete {runner}
		delete {hunters::*}
		delete {active}
		delete {paused}
		delete {time}
		delete {netherPortal}
		delete {endPortal}


every 2 seconds:
	if {active} is not true:
		stop
	if {paused} is true:
		stop

	loop {hunters::*}:
		set {_p} to loop-value
		if {_p} is online:
			if tool of {_p} is compass:
				if name of tool of {_p} is "&6&lTRACKER":
					if world of {_p} is world of {runner}:
						set compass target of {_p} to location of {runner}
					else if world of {runner} is world "world_nether":
						if {netherPortal} is set:
							set compass target of {_p} to {netherPortal}
					else if world of {runner} is world "world_the_end":
						if {endPortal} is set:
							set compass target of {_p} to {endPortal}


on portal:
	if {active} is true:
		if player is {runner}:
			if world of player is world "world_nether":
				set {netherPortal} to location of player
			else if world of player is world "world_the_end":
				set {endPortal} to location of player


on death:
	if {active} is not true:
		stop
	if {paused} is true:
		stop

	if victim is {runner}:
		broadcast "&cHunters win. %{runner}% has fallen."
		delete {runner}
		delete {hunters::*}
		delete {active}
		delete {paused}
		delete {time}
		delete {netherPortal}
		delete {endPortal}
		stop

	if victim is in {hunters::*}:
		set {drops.%uuid of victim%::*} to drops
		clear drops


on respawn:
	if {active} is true:
		if player is in {hunters::*}:
			wait 1 tick
			add {drops.%uuid of player%::*} to player's inventory
			delete {drops.%uuid of player%::*}
